{
    "docs": [
        {
            "location": "/",
            "text": "Rifraf.jl\n\n\nA Julia package for the RIFRAF sequence consensus algorithm.\n\n\nRIFRAF is a DNA consensus algorithm that is extremely accurate even for a small number of sequences. It uses quality scores and optionally takes a reference sequence for frame correction.\n\n\n\n\nExamples\n\n\n\n\nExamples\n\n\n\n\n\n\nAPI\n\n\n\n\nAPI\n\n\n\n\n\n\nCiting RIFRAF\n\n\nThis method has been submitted for publication. A link to the journal article will be added here when it is available.\n\n\n\n\nIndex\n\n\n\n\nRifraf.ErrorModel\n\n\nRifraf.RifrafParams\n\n\nRifraf.RifrafResult\n\n\nRifraf.Scores\n\n\nRifraf.read_fasta\n\n\nRifraf.read_fasta_records\n\n\nRifraf.read_fastq\n\n\nRifraf.read_fastq_records\n\n\nRifraf.read_samples\n\n\nRifraf.rifraf\n\n\nRifraf.sample_sequences\n\n\nRifraf.write_fasta\n\n\nRifraf.write_fastq\n\n\nRifraf.write_samples",
            "title": "Introduction"
        },
        {
            "location": "/#rifrafjl",
            "text": "A Julia package for the RIFRAF sequence consensus algorithm.  RIFRAF is a DNA consensus algorithm that is extremely accurate even for a small number of sequences. It uses quality scores and optionally takes a reference sequence for frame correction.",
            "title": "Rifraf.jl"
        },
        {
            "location": "/#examples",
            "text": "Examples",
            "title": "Examples"
        },
        {
            "location": "/#api",
            "text": "API",
            "title": "API"
        },
        {
            "location": "/#citing-rifraf",
            "text": "This method has been submitted for publication. A link to the journal article will be added here when it is available.",
            "title": "Citing RIFRAF"
        },
        {
            "location": "/#index",
            "text": "Rifraf.ErrorModel  Rifraf.RifrafParams  Rifraf.RifrafResult  Rifraf.Scores  Rifraf.read_fasta  Rifraf.read_fasta_records  Rifraf.read_fastq  Rifraf.read_fastq_records  Rifraf.read_samples  Rifraf.rifraf  Rifraf.sample_sequences  Rifraf.write_fasta  Rifraf.write_fastq  Rifraf.write_samples",
            "title": "Index"
        },
        {
            "location": "/examples/",
            "text": "Examples\n\n\nSome examples showing how to use RIFRAF.\n\n\n\n\nOn simulated data\n\n\nFirst, we generate a random 1,200 bp template, along with a reference and twenty simulated reads. We run RIFRAF both without and with the reference and compare the result to the expected template.\n\n\njulia> using Rifraf\n\njulia> sampled = sample_sequences(20, 1200);\n\njulia> (reference, template, _, sequences, _, phreds, _, _) = sampled;\n\njulia> result = rifraf(sequences, phreds;\n                       params=RifrafParams(batch_fixed_size=3, batch_size=5,\n                                           verbose=1, max_iters=20));\niteration 1 : STAGE_INIT : -Inf\niteration 2 : STAGE_INIT : -66.93546689716547\ndone. converged: true\n\njulia> result.consensus == template\nfalse\n\njulia> result = rifraf(sequences, phreds; reference=reference,\n                       params=RifrafParams(verbose=1, max_iters=20));\niteration 1 : STAGE_INIT : -Inf\niteration 2 : STAGE_INIT : -112.72329868969373\niteration 3 : STAGE_FRAME : -112.72329868969373\niteration 4 : STAGE_FRAME : -287.4380940401863\niteration 5 : STAGE_REFINE : -287.4380940401863\ndone. converged: true\n\njulia> result.consensus == template\ntrue\n\n\n\n\n\n\n\nReading data from FASTQ files\n\n\nRifraf.jl also provides a set of convenience functions for reading and writing FASTA and FASTQ files. For instance, here is one way to run RIFRAF on sequences from a file:\n\n\nsequences, phreds, names = Rifraf.read_fastq(\"/path/to/sequences.fastq\")\nreference = Rifraf.read_fasta(\"/path/to/reference.fasta\")[1]\nresult = rifraf(sequences, phreds; reference=reference)\n\n\n\n\n\nThere are also convenience functions for reading and writing the output of \nsample_sequences\n.\n\n\nreference, template, t_error, sequences, _, phreds, _, _ = sample_sequences()\nRifraf.write_samples(\"/path/to/basename\", reference, template, t_error, sequences, phreds)\nreference, template, t_error, sequences, phreds = Rifraf.read_samples(\"/path/to/basename\")\n\n\n\n\n\n\n\nCommand-line script\n\n\nscripts/rifraf.jl\n is a command-line script for processing many sets of reads at once. Julia takes some time to start up, so this script is only recommended for long sequences or large numbers of reads.\n\n\nThe \ndata\n directory includes some example data for testing this script. The following command finds a consensus for each FASTQ file that matches the glob \ninput-reads-*.fastq\n and writes them to \nresults.fasta\n.\n\n\njulia ./scripts/rifraf.jl \\\n    --reference ./data/references.fasta \\\n    --reference-map ./data/ref-map.tsv \\\n    --phred-cap 30 \\\n    --ref-errors 8,0.1,0.1,1,1 \\\n    1,2,2 \\\n    \"./data/input-reads-*.fastq\" \\\n    ./data/consensus-results.fasta\n\n\n\n\n\n\n\nAllowing frameshifts during frame correction\n\n\nRIFRAF's default parameters penalize frameshift-causing indels extremely heavily. If the template really does contain a frame shift mutation, it will likely be removed from the result. To detect real frameshifts, with a small risk of allowing some spurious ones, the penalties for single insertions or deletions must be tuned. For example:\n\n\njulia> using Rifraf\n\njulia> sampled = Rifraf.sample_sequences(5, 3001; error_rate=.005);\n\njulia> (reference, template, _, sequences, _, phreds, _, _) = sampled;\n\njulia> result = rifraf(sequences, phreds; reference=reference);\n\njulia> length(result.consensus) % 3 == 0\ntrue\n\njulia> result = rifraf(sequences, phreds; reference=reference,\n                       params=RifrafParams(ref_scores=Scores(ErrorModel(10, 1, 1, 1, 1)),\n                                           ref_indel_mult=1.2, max_ref_indel_mults=3));\n\njulia> length(result.consensus) % 3 == 0\nfalse",
            "title": "Examples"
        },
        {
            "location": "/examples/#examples",
            "text": "Some examples showing how to use RIFRAF.",
            "title": "Examples"
        },
        {
            "location": "/examples/#on-simulated-data",
            "text": "First, we generate a random 1,200 bp template, along with a reference and twenty simulated reads. We run RIFRAF both without and with the reference and compare the result to the expected template.  julia> using Rifraf\n\njulia> sampled = sample_sequences(20, 1200);\n\njulia> (reference, template, _, sequences, _, phreds, _, _) = sampled;\n\njulia> result = rifraf(sequences, phreds;\n                       params=RifrafParams(batch_fixed_size=3, batch_size=5,\n                                           verbose=1, max_iters=20));\niteration 1 : STAGE_INIT : -Inf\niteration 2 : STAGE_INIT : -66.93546689716547\ndone. converged: true\n\njulia> result.consensus == template\nfalse\n\njulia> result = rifraf(sequences, phreds; reference=reference,\n                       params=RifrafParams(verbose=1, max_iters=20));\niteration 1 : STAGE_INIT : -Inf\niteration 2 : STAGE_INIT : -112.72329868969373\niteration 3 : STAGE_FRAME : -112.72329868969373\niteration 4 : STAGE_FRAME : -287.4380940401863\niteration 5 : STAGE_REFINE : -287.4380940401863\ndone. converged: true\n\njulia> result.consensus == template\ntrue",
            "title": "On simulated data"
        },
        {
            "location": "/examples/#reading-data-from-fastq-files",
            "text": "Rifraf.jl also provides a set of convenience functions for reading and writing FASTA and FASTQ files. For instance, here is one way to run RIFRAF on sequences from a file:  sequences, phreds, names = Rifraf.read_fastq(\"/path/to/sequences.fastq\")\nreference = Rifraf.read_fasta(\"/path/to/reference.fasta\")[1]\nresult = rifraf(sequences, phreds; reference=reference)  There are also convenience functions for reading and writing the output of  sample_sequences .  reference, template, t_error, sequences, _, phreds, _, _ = sample_sequences()\nRifraf.write_samples(\"/path/to/basename\", reference, template, t_error, sequences, phreds)\nreference, template, t_error, sequences, phreds = Rifraf.read_samples(\"/path/to/basename\")",
            "title": "Reading data from FASTQ files"
        },
        {
            "location": "/examples/#command-line-script",
            "text": "scripts/rifraf.jl  is a command-line script for processing many sets of reads at once. Julia takes some time to start up, so this script is only recommended for long sequences or large numbers of reads.  The  data  directory includes some example data for testing this script. The following command finds a consensus for each FASTQ file that matches the glob  input-reads-*.fastq  and writes them to  results.fasta .  julia ./scripts/rifraf.jl \\\n    --reference ./data/references.fasta \\\n    --reference-map ./data/ref-map.tsv \\\n    --phred-cap 30 \\\n    --ref-errors 8,0.1,0.1,1,1 \\\n    1,2,2 \\\n    \"./data/input-reads-*.fastq\" \\\n    ./data/consensus-results.fasta",
            "title": "Command-line script"
        },
        {
            "location": "/examples/#allowing-frameshifts-during-frame-correction",
            "text": "RIFRAF's default parameters penalize frameshift-causing indels extremely heavily. If the template really does contain a frame shift mutation, it will likely be removed from the result. To detect real frameshifts, with a small risk of allowing some spurious ones, the penalties for single insertions or deletions must be tuned. For example:  julia> using Rifraf\n\njulia> sampled = Rifraf.sample_sequences(5, 3001; error_rate=.005);\n\njulia> (reference, template, _, sequences, _, phreds, _, _) = sampled;\n\njulia> result = rifraf(sequences, phreds; reference=reference);\n\njulia> length(result.consensus) % 3 == 0\ntrue\n\njulia> result = rifraf(sequences, phreds; reference=reference,\n                       params=RifrafParams(ref_scores=Scores(ErrorModel(10, 1, 1, 1, 1)),\n                                           ref_indel_mult=1.2, max_ref_indel_mults=3));\n\njulia> length(result.consensus) % 3 == 0\nfalse",
            "title": "Allowing frameshifts during frame correction"
        },
        {
            "location": "/api/",
            "text": "API\n\n\nThe main functions and types in Rifraf.jl.\n\n\n\n\nFunctions\n\n\n#\n\n\nRifraf.rifraf\n \u2014 \nFunction\n.\n\n\nrifraf(dnaseqs, phreds; kwargs...)\n\n\n\n\n\nFind a consensus sequence for a set of DNA sequences.\n\n\nReturns an instance of \nRifrafResult\n.\n\n\nArguments\n\n\n\n\ndnaseqs::Vector{DNASeq}\n: reads for which to find a consensus\n\n\nphreds::Vector{Vector{Phred}}\n: Phred scores for \ndnaseqs\n\n\nconsensus::DNASeq=DNASeq()\n: initial consensus; if not given, defaults to the sequence in \ndnaseqs\n with the lowest mean error rate\n\n\nreference::DNASeq=DNASeq()\n: reference for frame correction\n\n\nparams::RifrafParams=RifrafParams()\n\n\n\n\nsource\n\n\n\n\nSequence simulations\n\n\n#\n\n\nRifraf.sample_sequences\n \u2014 \nFunction\n.\n\n\nsample_sequences(nseqs, len; kwargs...)\n\n\n\n\n\nGenerate a template and sample simulated reads and Phred scores.\n\n\nThis function is meant for simple testing and benchmarking, and is not meant to represent a realistic error model.\n\n\nArguments:\n\n\n\n\nnseqs::Int=3\n: number of reads to generate\n\n\nlen::Int=90\n: length of template\n\n\nref_error_rate::Prob=0.1\n: reference error rate\n\n\nref_errors::ErrorModel=ErrorModel(10, 0, 0, 1, 1)\n: reference error model\n\n\nerror_rate::Prob=0.01\n: read error rate\n\n\nalpha::Float64=0.1\n: \u03b1 parameter for beta distribution of per-base template error rates.\n\n\nphred_scale::Float64=1.5\n: \u03bb parameter for exponential distribution of Phred error\n\n\nactual_std::Float64=3.0\n: \u03c3^2 for true Gaussian errors in the Phred domain\n\n\nreported_std::Float64=1.0\n: \u03c3^2 for Gaussian errors in the Phred domain\n\n\nseq_errors::ErrorModel=ErrorModel(1, 5, 5)\n: sequencing error model\n\n\n\n\nReturns:\n\n\n\n\nreference::DNASeq\n: reference sequence for \ntemplate\n\n\ntemplate::DNASeq\n: template sequence\n\n\nt_p::Vector{Prob}\n: template error probabilities\n\n\nseqs::Vector{DNASeq}\n: simulated reads\n\n\nactual::Vector{Vector{Prob}}\n: error probabilities\n\n\nphreds::{Vector{Vector{Phred}}\n: Phred values\n\n\nseqbools::Vector{Vector{Bool}}\n: \nseqbools[i][j]\n is \ntrue\n if \nseqs[i][j]\n was correctly sequenced from the template\n\n\ntbools::Vector{Vector{Bool}}\n: \ntbools[i][j]\n is \ntrue\n if \ntemplate[j]\n was correctly sequenced in \nseqs[i]\n\n\n\n\nsource\n\n\n#\n\n\nRifraf.write_samples\n \u2014 \nFunction\n.\n\n\nWrite template into FASTA and sequences into FASTQ.\n\n\nsource\n\n\n#\n\n\nRifraf.read_samples\n \u2014 \nFunction\n.\n\n\nRead template from FASTA and sequences from FASTQ.\n\n\nsource\n\n\n\n\nUtility IO functions\n\n\nRifraf.jl provides some utility functions for reading and writing FASTQ and FASTA files. This functionality uses BioSequences.jl.\n\n\n#\n\n\nRifraf.read_fastq_records\n \u2014 \nFunction\n.\n\n\nread_fastq_records(filename)\n\n\n\n\n\nRead a FASTQ file and return records.\n\n\nReturns:\n\n\n\n\nrecords::Vector{FASTQ.Record}\n\n\n\n\nsource\n\n\n#\n\n\nRifraf.read_fastq\n \u2014 \nFunction\n.\n\n\nread_fastq(filename)\n\n\n\n\n\nRead a FASTQ file and convert to a given sequence type.\n\n\nReturns:\n\n\n\n\nseqs::Vector{T}\n:\n\n\nphreds::Vector{Vector{Phred}}\n: Phred values\n\n\nnames::Vector{String}\n: sequence names\n\n\n\n\nsource\n\n\n#\n\n\nRifraf.write_fastq\n \u2014 \nFunction\n.\n\n\nwrite_fastq(filename, seqs, phreds; names)\n\n\n\n\n\nWrite sequences to a FASTA file.\n\n\nArguments:\n\n\n\n\nfilename\n: file into which to write\n\n\nseqs\n: sequences to write\n\n\nphreds\n: corresponding Phred scores\n\n\nnames::Vector{String}\n: optional list of corresponding names\n\n\n\n\nsource\n\n\n#\n\n\nRifraf.read_fasta_records\n \u2014 \nFunction\n.\n\n\nread_fasta_records(filename)\n\n\n\n\n\nRead a FASTA file and return records.\n\n\nReturns:\n\n\n\n\nrecords::Vector{FASTA.Record}\n\n\n\n\nsource\n\n\n#\n\n\nRifraf.read_fasta\n \u2014 \nFunction\n.\n\n\nread_fasta(filename)\n\n\n\n\n\nRead a FASTA file and convert to a given sequence type.\n\n\nReturns:\n\n\n\n\nseqs::Vector{T}\n\n\n\n\nsource\n\n\n#\n\n\nRifraf.write_fasta\n \u2014 \nFunction\n.\n\n\nwrite_fasta(filename, seqs; names)\n\n\n\n\n\nWrite sequences to a FASTA file.\n\n\nArguments:\n\n\n\n\nfilename\n: file into which to write\n\n\nseqs\n: sequences to write\n\n\nnames::Vector{String}\n: optional list of corresponding names\n\n\n\n\nsource\n\n\n\n\nTypes\n\n\n#\n\n\nRifraf.RifrafParams\n \u2014 \nType\n.\n\n\nThe parameters for a RIFRAF run.\n\n\nFields\n\n\n\n\nscores::Scores = Scores(ErrorModel(1.0, 2.0, 2.0, 0.0, 0.0))\n\n\nref_scores::Scores = Scores(ErrorModel(10.0, 1e-1, 1e-1, 1.0, 1.0))\n\n\nref_indel_mult::Score = 3.0\n: multiplier for single indel penalties in alignment with the reference\n\n\nmax_ref_indel_mults::Int = 5\n: maximum multiplier increases for single indel penalty\n\n\nref_error_mult::Float64 = 1.0\n: multiplier for estimated reference error rate.\n\n\ndo_init::Bool = true\n: enable initialization stage\n\n\ndo_frame::Bool = true\n: enable frame correction stage\n\n\ndo_refine::Bool = true\n: enable refinement stage\n\n\ndo_score::Bool = false\n: enable scoring stage\n\n\ndo_alignment_proposals::Bool = true\n: only propose changes that occur in pairwise alignments\n\n\nseed_indels::Bool = true\n: seed indel locations from the alignment to reference\n\n\nindel_correction_only::Bool = true\n: only propose indels during frame correction stage\n\n\nuse_ref_for_qvs::Bool = false\n: use reference alignment when estimating quality scores\n\n\nbandwidth::Int = (3 * CODON_LENGTH)\n: alignment bandwidth\n\n\nbandwidth_pvalue::Float64 = 0.1\n: p-value for increasing bandwidth\n\n\nmin_dist::Int = (5 * CODON_LENGTH)\n: distance between accepted candidate proposals\n\n\nbatch_fixed::Bool = true\n: use top sequences for initial stage and frame correction\n\n\nbatch_fixed_size::Int = 5\n: size of fixed batch\n\n\nbatch_size::Int = 20\n: batch size; if <= 1, no batching is used\n\n\n\n\nbatch_randomness::Float64 = 0.9\n: batch randomness\n\n\n\n\n0\n: top n get picked\n\n\n0.5\n: weight according to estimated errors\n\n\n1\n: completely random\n\n\nbatch_mult::Float64 = 0.7\n: multiplier to reduce batch randomness\n\n\nbatch_threshold::Float64 = 0.1\n: score threshold for increasing batch size\n\n\nmax_iters::Int = 100\n: maximum total iterations across all stages before giving up\n\n\n\n\nverbose::Int = 0\n: verbosity level\n\n\n\n\n\n\n0\n: nothing\n\n\n\n\n1\n: print iteration and score\n\n\n2\n: also print step within each iteration\n\n\n3\n: also print full consensus sequence\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nRifraf.RifrafResult\n \u2014 \nType\n.\n\n\nRifrafResult()\n\n\n\n\n\nThe result of a RIFRAF run.\n\n\nFields\n\n\n\n\nconsensus::DNASeq\n: the consensus found by RIFRAF.\n\n\nparams::RifrafParams\n: the parameters used for this run.\n\n\nstate::RifrafState\n: the final state of the run.\n\n\nconsensus_stages::Vector{Vector{DNASeq}}\n:\n\n\nerror_probs::EstimatedProbs\n: estimated per-base probabilities for each position. Only available if \nparams.do_score\n is \ntrue\n.\n\n\naln_error_probs::Vector{Float64}\n: combined per-base error probabilities. Only available if \nparams.do_score\n is \ntrue\n.\n\n\n\n\nsource\n\n\n#\n\n\nRifraf.ErrorModel\n \u2014 \nType\n.\n\n\nErrorModel(mismatch, insertion, deletion, codon_insertion, codon_deletion)\n\n\n\n\n\nError model for sequencing.\n\n\nEach field contains the relative rate of of that kind of error. For instance, this model breaks the error rate into 80% mismatches, 10% codon insertions, and 10% codon deletions: \nErrorModel(8, 0, 0, 1, 1)\n.\n\n\nFields:\n\n\n\n\nmismatch::Real\n\n\ninsertion::Real\n\n\ndeletion::Real\n\n\ncodon_insertion::Real\n\n\ncodon_deletion::Real\n\n\n\n\nsource\n\n\n#\n\n\nRifraf.Scores\n \u2014 \nType\n.\n\n\nScores(errors; mismatch, insertion, deletion)\n\n\n\n\n\nDerive alignment scores from an error model.\n\n\nTakes extra penalties to add to the mismatch, insertion, and deletion scores.\n\n\nArguments:\n\n\n\n\nerrors::ErrorModel\n:\n\n\nmismatch::Real\n: substitution\n\n\ninsertion::Real\n: insertion\n\n\ndeletion::Real\n: deletion\n\n\n\n\nsource",
            "title": "API"
        },
        {
            "location": "/api/#api",
            "text": "The main functions and types in Rifraf.jl.",
            "title": "API"
        },
        {
            "location": "/api/#functions",
            "text": "#  Rifraf.rifraf  \u2014  Function .  rifraf(dnaseqs, phreds; kwargs...)  Find a consensus sequence for a set of DNA sequences.  Returns an instance of  RifrafResult .  Arguments   dnaseqs::Vector{DNASeq} : reads for which to find a consensus  phreds::Vector{Vector{Phred}} : Phred scores for  dnaseqs  consensus::DNASeq=DNASeq() : initial consensus; if not given, defaults to the sequence in  dnaseqs  with the lowest mean error rate  reference::DNASeq=DNASeq() : reference for frame correction  params::RifrafParams=RifrafParams()   source",
            "title": "Functions"
        },
        {
            "location": "/api/#sequence-simulations",
            "text": "#  Rifraf.sample_sequences  \u2014  Function .  sample_sequences(nseqs, len; kwargs...)  Generate a template and sample simulated reads and Phred scores.  This function is meant for simple testing and benchmarking, and is not meant to represent a realistic error model.  Arguments:   nseqs::Int=3 : number of reads to generate  len::Int=90 : length of template  ref_error_rate::Prob=0.1 : reference error rate  ref_errors::ErrorModel=ErrorModel(10, 0, 0, 1, 1) : reference error model  error_rate::Prob=0.01 : read error rate  alpha::Float64=0.1 : \u03b1 parameter for beta distribution of per-base template error rates.  phred_scale::Float64=1.5 : \u03bb parameter for exponential distribution of Phred error  actual_std::Float64=3.0 : \u03c3^2 for true Gaussian errors in the Phred domain  reported_std::Float64=1.0 : \u03c3^2 for Gaussian errors in the Phred domain  seq_errors::ErrorModel=ErrorModel(1, 5, 5) : sequencing error model   Returns:   reference::DNASeq : reference sequence for  template  template::DNASeq : template sequence  t_p::Vector{Prob} : template error probabilities  seqs::Vector{DNASeq} : simulated reads  actual::Vector{Vector{Prob}} : error probabilities  phreds::{Vector{Vector{Phred}} : Phred values  seqbools::Vector{Vector{Bool}} :  seqbools[i][j]  is  true  if  seqs[i][j]  was correctly sequenced from the template  tbools::Vector{Vector{Bool}} :  tbools[i][j]  is  true  if  template[j]  was correctly sequenced in  seqs[i]   source  #  Rifraf.write_samples  \u2014  Function .  Write template into FASTA and sequences into FASTQ.  source  #  Rifraf.read_samples  \u2014  Function .  Read template from FASTA and sequences from FASTQ.  source",
            "title": "Sequence simulations"
        },
        {
            "location": "/api/#utility-io-functions",
            "text": "Rifraf.jl provides some utility functions for reading and writing FASTQ and FASTA files. This functionality uses BioSequences.jl.  #  Rifraf.read_fastq_records  \u2014  Function .  read_fastq_records(filename)  Read a FASTQ file and return records.  Returns:   records::Vector{FASTQ.Record}   source  #  Rifraf.read_fastq  \u2014  Function .  read_fastq(filename)  Read a FASTQ file and convert to a given sequence type.  Returns:   seqs::Vector{T} :  phreds::Vector{Vector{Phred}} : Phred values  names::Vector{String} : sequence names   source  #  Rifraf.write_fastq  \u2014  Function .  write_fastq(filename, seqs, phreds; names)  Write sequences to a FASTA file.  Arguments:   filename : file into which to write  seqs : sequences to write  phreds : corresponding Phred scores  names::Vector{String} : optional list of corresponding names   source  #  Rifraf.read_fasta_records  \u2014  Function .  read_fasta_records(filename)  Read a FASTA file and return records.  Returns:   records::Vector{FASTA.Record}   source  #  Rifraf.read_fasta  \u2014  Function .  read_fasta(filename)  Read a FASTA file and convert to a given sequence type.  Returns:   seqs::Vector{T}   source  #  Rifraf.write_fasta  \u2014  Function .  write_fasta(filename, seqs; names)  Write sequences to a FASTA file.  Arguments:   filename : file into which to write  seqs : sequences to write  names::Vector{String} : optional list of corresponding names   source",
            "title": "Utility IO functions"
        },
        {
            "location": "/api/#types",
            "text": "#  Rifraf.RifrafParams  \u2014  Type .  The parameters for a RIFRAF run.  Fields   scores::Scores = Scores(ErrorModel(1.0, 2.0, 2.0, 0.0, 0.0))  ref_scores::Scores = Scores(ErrorModel(10.0, 1e-1, 1e-1, 1.0, 1.0))  ref_indel_mult::Score = 3.0 : multiplier for single indel penalties in alignment with the reference  max_ref_indel_mults::Int = 5 : maximum multiplier increases for single indel penalty  ref_error_mult::Float64 = 1.0 : multiplier for estimated reference error rate.  do_init::Bool = true : enable initialization stage  do_frame::Bool = true : enable frame correction stage  do_refine::Bool = true : enable refinement stage  do_score::Bool = false : enable scoring stage  do_alignment_proposals::Bool = true : only propose changes that occur in pairwise alignments  seed_indels::Bool = true : seed indel locations from the alignment to reference  indel_correction_only::Bool = true : only propose indels during frame correction stage  use_ref_for_qvs::Bool = false : use reference alignment when estimating quality scores  bandwidth::Int = (3 * CODON_LENGTH) : alignment bandwidth  bandwidth_pvalue::Float64 = 0.1 : p-value for increasing bandwidth  min_dist::Int = (5 * CODON_LENGTH) : distance between accepted candidate proposals  batch_fixed::Bool = true : use top sequences for initial stage and frame correction  batch_fixed_size::Int = 5 : size of fixed batch  batch_size::Int = 20 : batch size; if <= 1, no batching is used   batch_randomness::Float64 = 0.9 : batch randomness   0 : top n get picked  0.5 : weight according to estimated errors  1 : completely random  batch_mult::Float64 = 0.7 : multiplier to reduce batch randomness  batch_threshold::Float64 = 0.1 : score threshold for increasing batch size  max_iters::Int = 100 : maximum total iterations across all stages before giving up   verbose::Int = 0 : verbosity level    0 : nothing   1 : print iteration and score  2 : also print step within each iteration  3 : also print full consensus sequence     source  #  Rifraf.RifrafResult  \u2014  Type .  RifrafResult()  The result of a RIFRAF run.  Fields   consensus::DNASeq : the consensus found by RIFRAF.  params::RifrafParams : the parameters used for this run.  state::RifrafState : the final state of the run.  consensus_stages::Vector{Vector{DNASeq}} :  error_probs::EstimatedProbs : estimated per-base probabilities for each position. Only available if  params.do_score  is  true .  aln_error_probs::Vector{Float64} : combined per-base error probabilities. Only available if  params.do_score  is  true .   source  #  Rifraf.ErrorModel  \u2014  Type .  ErrorModel(mismatch, insertion, deletion, codon_insertion, codon_deletion)  Error model for sequencing.  Each field contains the relative rate of of that kind of error. For instance, this model breaks the error rate into 80% mismatches, 10% codon insertions, and 10% codon deletions:  ErrorModel(8, 0, 0, 1, 1) .  Fields:   mismatch::Real  insertion::Real  deletion::Real  codon_insertion::Real  codon_deletion::Real   source  #  Rifraf.Scores  \u2014  Type .  Scores(errors; mismatch, insertion, deletion)  Derive alignment scores from an error model.  Takes extra penalties to add to the mismatch, insertion, and deletion scores.  Arguments:   errors::ErrorModel :  mismatch::Real : substitution  insertion::Real : insertion  deletion::Real : deletion   source",
            "title": "Types"
        }
    ]
}